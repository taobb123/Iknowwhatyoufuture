
### 协同工作（数据库 + 前端缓存）

这个组合拳的打法，可以用一个典型的用户场景来描述：**“用户访问个人主页”**

1.  **首次访问（缓存未命中）**
    *   用户打开网站，进入个人主页。
    *   前端检查本地缓存（如 `localStorage` 或 `sessionStorage`）中是否有 `userProfile` 数据。
    *   **没有找到**，于是前端向服务器发起 API 请求。
    *   服务器接收到请求，从**数据库**中查询该用户的完整个人信息。
    *   服务器将数据返回给前端。
    *   前端将收到的数据**渲染到页面上**，同时**将这份数据存入前端缓存**，并设置一个合理的过期时间（例如5分钟）。

2.  **5分钟内的再次访问（缓存命中）**
    *   用户在同一浏览器标签页中刷新页面。
    *   前端再次检查本地缓存，**找到了** `userProfile` 数据。
    *   **前端立即使用这份缓存数据来渲染页面**，页面瞬间呈现，无需等待网络。
    *   同时，前端可能在背后**悄悄地**（或根据用户操作）向服务器发起一个验证请求，检查数据是否有更新。如果有更新，则用新数据替换旧缓存并更新页面。

3.  **数据更新（保证一致性）**
    *   用户修改了自己的昵称并点击保存。
    *   前端将新昵称发送给服务器。
    *   **服务器在数据库中将昵称更新成功**。
    *   服务器返回“更新成功”的响应给前端。
    *   **前端在收到成功响应后，必须做一件事：使旧的缓存失效**。具体可以是：
        *   **直接更新缓存**：将新的用户资料（包含新昵称）重新写入缓存。
        *   **删除缓存**：直接删除 `userProfile` 这个缓存项，迫使下次访问时从数据库拉取最新数据。

这个流程确保了：
*   **性能极致**：大部分重复访问是瞬间完成的。
*   **数据可靠**：所有变更都以数据库为准。
*   **最终一致**：前端缓存可能会短暂落后，但通过失效策略，能快速恢复到一致状态。